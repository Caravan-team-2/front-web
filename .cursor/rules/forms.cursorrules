# Forms Rules

## AI Assistant Behavior
You are an expert in React form development with deep knowledge of React Hook Form, Zod validation, and Shadcn/ui components. You create accessible, type-safe, and user-friendly forms with comprehensive validation and error handling.

## Response Guidelines
- Design form architecture step-by-step with proper validation strategy
- Always use React Hook Form (useForm) for form state management
- Always use Zod for schema validation and type inference
- Always use Shadcn/ui components for consistent form UI
- Implement proper accessibility features for all form elements
- Create reusable form patterns and validation schemas
- Write complete, production-ready form code with no placeholders
- Include proper error handling and user feedback mechanisms

## MANDATORY Form Architecture
**ALL forms MUST follow this structure:**

1. **Zod Schema**: Define validation schema in constants/schemas folder
2. **Form Component**: Use useForm with Zod resolver
3. **Shadcn Components**: Use Form, FormField, FormItem, FormLabel, FormControl, FormMessage
4. **Error Handling**: Implement proper validation and submission error handling
5. **Accessibility**: Include proper ARIA attributes and keyboard navigation
6. **TypeScript**: Infer types from Zod schemas

## Zod Schema Patterns

### Schema Organization
```typescript
// src/constants/schemas/userSchemas.ts
import { z } from 'zod';

export const createUserSchema = z.object({
  name: z.string().min(2, 'Name must be at least 2 characters'),
  email: z.string().email('Please enter a valid email'),
  age: z.number().min(18, 'Must be at least 18 years old').optional(),
  role: z.enum(['admin', 'user'], {
    required_error: 'Please select a role'
  })
});

export const updateUserSchema = createUserSchema.partial();

export type CreateUserForm = z.infer<typeof createUserSchema>;
export type UpdateUserForm = z.infer<typeof updateUserSchema>;
```

### Reusable Schema Patterns
- Create base schemas for common field types (email, phone, password)
- Use schema composition with .merge() for complex forms
- Implement conditional validation with .superRefine()
- Create schema unions for different form variants
- Use .transform() for data normalization
- Implement custom validation with .refine()

### Common Validation Patterns
```typescript
// src/constants/schemas/commonSchemas.ts
export const emailSchema = z.string().email('Please enter a valid email');
export const passwordSchema = z.string()
  .min(8, 'Password must be at least 8 characters')
  .regex(/[A-Z]/, 'Password must contain uppercase letter')
  .regex(/[0-9]/, 'Password must contain number');

export const phoneSchema = z.string()
  .regex(/^\+?[1-9]\d{1,14}$/, 'Please enter a valid phone number');

export const urlSchema = z.string().url('Please enter a valid URL');
```

## React Hook Form Implementation

### useForm Configuration
```typescript
// Always use Zod resolver
const form = useForm<CreateUserForm>({
  resolver: zodResolver(createUserSchema),
  defaultValues: {
    name: '',
    email: '',
    role: undefined
  },
  mode: 'onChange', // Real-time validation
  reValidateMode: 'onChange'
});
```

### Form State Management Rules
- Use useForm for all form state management
- Implement proper default values for all fields
- Use mode: 'onChange' for real-time validation
- Implement proper form reset functionality
- Use watch() for dependent field logic
- Implement proper form dirty/touched state handling

### Form Submission Patterns
```typescript
const onSubmit = async (data: CreateUserForm) => {
  try {
    setIsSubmitting(true);
    await createUser(data);
    form.reset();
    toast.success('User created successfully');
  } catch (error) {
    handleFormError(error, form);
  } finally {
    setIsSubmitting(false);
  }
};
```

## Shadcn/ui Form Components

### Required Shadcn Components
- **Form**: Root form wrapper with FormProvider
- **FormField**: Individual field wrapper with Controller
- **FormItem**: Field container with proper spacing
- **FormLabel**: Accessible field labels
- **FormControl**: Input wrapper for proper styling
- **FormDescription**: Helper text for fields
- **FormMessage**: Error message display

### Form Structure Pattern
```typescript
<Form {...form}>
  <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
    <FormField
      control={form.control}
      name="name"
      render={({ field }) => (
        <FormItem>
          <FormLabel>Name</FormLabel>
          <FormControl>
            <Input placeholder="Enter your name" {...field} />
          </FormControl>
          <FormDescription>
            This will be displayed as your public name
          </FormDescription>
          <FormMessage />
        </FormItem>
      )}
    />
    <Button type="submit" disabled={isSubmitting}>
      {isSubmitting ? 'Creating...' : 'Create User'}
    </Button>
  </form>
</Form>
```

### Shadcn Input Components
- **Input**: Text inputs with proper styling
- **Textarea**: Multi-line text input
- **Select**: Dropdown selections
- **Checkbox**: Boolean selections
- **RadioGroup**: Single choice from multiple options
- **Switch**: Toggle controls
- **DatePicker**: Date selection (with date-fns)
- **Combobox**: Searchable selections

## Field Types and Validation

### Text Input Fields
```typescript
// String fields with various validations
<FormField
  control={form.control}
  name="email"
  render={({ field }) => (
    <FormItem>
      <FormLabel>Email</FormLabel>
      <FormControl>
        <Input type="email" placeholder="user@example.com" {...field} />
      </FormControl>
      <FormMessage />
    </FormItem>
  )}
/>
```

### Number Input Fields
```typescript
// Number fields with proper validation
<FormField
  control={form.control}
  name="age"
  render={({ field }) => (
    <FormItem>
      <FormLabel>Age</FormLabel>
      <FormControl>
        <Input 
          type="number" 
          {...field}
          onChange={(e) => field.onChange(parseInt(e.target.value) || 0)}
        />
      </FormControl>
      <FormMessage />
    </FormItem>
  )}
/>
```

### Select Fields
```typescript
// Select dropdowns with Shadcn Select
<FormField
  control={form.control}
  name="role"
  render={({ field }) => (
    <FormItem>
      <FormLabel>Role</FormLabel>
      <Select onValueChange={field.onChange} defaultValue={field.value}>
        <FormControl>
          <SelectTrigger>
            <SelectValue placeholder="Select a role" />
          </SelectTrigger>
        </FormControl>
        <SelectContent>
          <SelectItem value="admin">Admin</SelectItem>
          <SelectItem value="user">User</SelectItem>
        </SelectContent>
      </Select>
      <FormMessage />
    </FormItem>
  )}
/>
```

### Checkbox Fields
```typescript
// Checkbox fields with proper handling
<FormField
  control={form.control}
  name="acceptTerms"
  render={({ field }) => (
    <FormItem className="flex flex-row items-start space-x-3 space-y-0">
      <FormControl>
        <Checkbox
          checked={field.value}
          onCheckedChange={field.onChange}
        />
      </FormControl>
      <div className="space-y-1 leading-none">
        <FormLabel>Accept terms and conditions</FormLabel>
        <FormDescription>
          You agree to our Terms of Service and Privacy Policy.
        </FormDescription>
      </div>
      <FormMessage />
    </FormItem>
  )}
/>
```

## Advanced Form Patterns

### Multi-Step Forms
```typescript
// Multi-step form with step validation
const steps = [
  { schema: personalInfoSchema, component: PersonalInfoStep },
  { schema: contactInfoSchema, component: ContactInfoStep },
  { schema: preferencesSchema, component: PreferencesStep }
];

const [currentStep, setCurrentStep] = useState(0);
const currentSchema = steps[currentStep].schema;

const form = useForm({
  resolver: zodResolver(currentSchema),
  mode: 'onChange'
});
```

### Dynamic Form Fields
```typescript
// Dynamic field arrays with useFieldArray
const { fields, append, remove } = useFieldArray({
  control: form.control,
  name: 'addresses'
});

// Add/remove fields dynamically
const addAddress = () => append({ street: '', city: '', zipCode: '' });
const removeAddress = (index: number) => remove(index);
```

### Conditional Fields
```typescript
// Conditional field rendering based on other field values
const watchRole = form.watch('role');

{watchRole === 'admin' && (
  <FormField
    control={form.control}
    name="adminLevel"
    render={({ field }) => (
      // Admin-specific field
    )}
  />
)}
```

### File Upload Fields
```typescript
// File upload with validation
const fileSchema = z.object({
  file: z.instanceof(File)
    .refine(file => file.size <= 5000000, 'File size must be less than 5MB')
    .refine(file => ['image/jpeg', 'image/png'].includes(file.type), 'Only JPEG and PNG files allowed')
});

<FormField
  control={form.control}
  name="file"
  render={({ field }) => (
    <FormItem>
      <FormLabel>Upload File</FormLabel>
      <FormControl>
        <Input
          type="file"
          accept="image/jpeg,image/png"
          onChange={(e) => field.onChange(e.target.files?.[0])}
        />
      </FormControl>
      <FormMessage />
    </FormItem>
  )}
/>
```

## Form Error Handling

### Validation Error Display
```typescript
// Custom error handling for complex validations
const handleFormError = (error: any, form: UseFormReturn) => {
  if (error.validationErrors) {
    Object.entries(error.validationErrors).forEach(([field, message]) => {
      form.setError(field as keyof FormData, { 
        type: 'server', 
        message: message as string 
      });
    });
  } else {
    toast.error(error.message || 'Something went wrong');
  }
};
```

### Server-Side Validation Integration
```typescript
// Handle server validation errors
const onSubmit = async (data: FormData) => {
  try {
    await submitForm(data);
  } catch (error) {
    if (error.status === 422) {
      // Handle validation errors from server
      error.data.errors.forEach(({ field, message }) => {
        form.setError(field, { type: 'server', message });
      });
    } else {
      toast.error('Submission failed. Please try again.');
    }
  }
};
```

## Form Accessibility

### Required Accessibility Features
- Use proper semantic HTML with form elements
- Implement proper label associations
- Include ARIA attributes for complex form controls
- Provide clear error messages with proper announcements
- Implement keyboard navigation for all form elements
- Use fieldset and legend for grouped form controls
- Provide proper focus management and indicators

### ARIA Implementation
```typescript
<FormField
  control={form.control}
  name="password"
  render={({ field }) => (
    <FormItem>
      <FormLabel>Password</FormLabel>
      <FormControl>
        <Input
          type="password"
          aria-describedby="password-help password-error"
          {...field}
        />
      </FormControl>
      <FormDescription id="password-help">
        Must be at least 8 characters with uppercase and number
      </FormDescription>
      <FormMessage id="password-error" />
    </FormItem>
  )}
/>
```

## Form Performance Optimization

### Optimization Strategies
- Use React.memo for expensive form components
- Implement proper field-level validation debouncing
- Use useCallback for form submission handlers
- Minimize unnecessary re-renders with proper dependencies
- Implement form field lazy loading for large forms
- Use proper key props for dynamic field arrays

### Loading States
```typescript
// Proper loading states for form submission
const [isSubmitting, setIsSubmitting] = useState(false);

<Button type="submit" disabled={isSubmitting || !form.formState.isValid}>
  {isSubmitting && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
  {isSubmitting ? 'Creating...' : 'Create User'}
</Button>
```

## Form Testing

### Testing Patterns
- Test form validation with various input scenarios
- Test form submission with success/error cases
- Test accessibility features with screen readers
- Test keyboard navigation and focus management
- Test form performance with large datasets
- Create integration tests for complete form workflows

## Code Implementation Rules
- Always use useForm from React Hook Form for form state
- Always use Zod for schema validation and type inference
- Always use Shadcn/ui components for consistent form styling
- Separate validation schemas into constants/schemas folder
- Implement proper error handling at form and field level
- Use TypeScript types inferred from Zod schemas
- Include proper accessibility attributes for all form elements
- Implement loading states for form submissions
- Create reusable form components and validation patterns
- Test forms thoroughly including edge cases and error scenarios

## Common Anti-Patterns to Avoid
- Using useState for complex form state management
- Implementing custom validation instead of using Zod
- Not providing proper error messages for validation failures
- Ignoring accessibility requirements for form elements
- Not handling server-side validation errors properly
- Using uncontrolled components without proper integration
- Not implementing proper loading states during submission
- Creating forms without proper TypeScript typing
- Not testing form validation and submission scenarios

## Required Folder Structure
```
src/
├── constants/
│   └── schemas/             # Zod validation schemas
│       ├── userSchemas.ts
│       ├── commonSchemas.ts
│       └── index.ts
├── components/
│   ├── forms/              # Reusable form components
│   │   ├── UserForm.tsx
│   │   ├── FormFields/     # Custom form field components
│   │   └── FormWrappers/   # Form layout components
│   └── ui/                 # Shadcn/ui components
│       ├── form.tsx
│       ├── input.tsx
│       ├── button.tsx
│       └── select.tsx
├── hooks/
│   └── useForms.ts         # Custom form hooks
├── types/
│   └── forms.ts           # Form-specific types
└── utils/
    ├── formValidation.ts   # Form validation utilities
    └── formHelpers.ts     # Form helper functions
```

## Form Component Template
```typescript
// Template for all form components
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { Form, FormField, FormItem, FormLabel, FormControl, FormMessage } from '@/components/ui/form';
import { Input } from '@/components/ui/input';
import { Button } from '@/components/ui/button';

const formSchema = z.object({
  // Define schema here
});

type FormData = z.infer<typeof formSchema>;

export const YourForm = () => {
  const form = useForm<FormData>({
    resolver: zodResolver(formSchema),
    defaultValues: {
      // Define defaults
    },
    mode: 'onChange'
  });

  const onSubmit = async (data: FormData) => {
    // Handle submission
  };

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
        {/* Form fields */}
        <Button type="submit" disabled={isSubmitting}>
          Submit
        </Button>
      </form>
    </Form>
  );
};
```